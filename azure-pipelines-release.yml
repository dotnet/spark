# Spark .NET build

trigger:
  batch: true
  branches:
    include:
    - main

variables:
  buildConfiguration: 'Release'
  _SignType: real
  _TeamName: DotNetSpark
  MSBUILDSINGLELOADCONTEXT: 1
  ArtifactPath: '$(Build.ArtifactStagingDirectory)/Binaries'

  forwardCompatibleRelease: '2.0.0'

  # Azure DevOps variables are transformed into environment variables, with these variables we
  # avoid the first time experience and telemetry to speed up the build.
  DOTNET_CLI_TELEMETRY_OPTOUT: 1
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1

resources:
  repositories:
  - repository: forwardCompatibleRelease
    type: github
    endpoint: dotnet.spark
    name: dotnet/spark
    ref: refs/tags/v$(forwardCompatibleRelease)
  
  - repository: 1ESPipelineTemplates
    type: git
    name: 1ESPipelineTemplates/1ESPipelineTemplates
    ref: refs/tags/release

extends:
  template: v1/1ES.Official.PipelineTemplate.yml@1ESPipelineTemplates
  parameters:
    settings:
      skipBuildTagsForGitHubPullRequests: true
    sdl:
      spotBugs:
        enabled: false
      suppression:
        suppressionFile: $(Build.SourcesDirectory)\.config\guardian\.gdnsuppress
      PSScriptAnalyzer:
        enabled: false
      credscan:
        enabled: false
      sourceRepositoriesToScan:
        exclude:
          - repository: forwardCompatibleRelease
      # Specify Windows pool for SDL source analysis stage
      sourceAnalysisPool:
        name: Cosmos2MT-AzureDevOps-AgentPool
        image: 1es-pt-windows-2022
        os: windows
    pool:
      name: Cosmos2MT-AzureDevOps-AgentPool
      image: 1es-pt-windows-2019
      os: windows
    customBuildTags:
      - ES365AIMigrationTooling
          
    stages:
    - stage: Build
      displayName: Build Sources
      jobs:
      - job: Build
        templateContext:
          outputs:
            - output: pipelineArtifact
              artifactName: DotnetSpark
              targetPath: $(ArtifactPath)\Output
              displayName: '[PUBLISH] Spark.Net Artifact'

        variables:
              ? ${{ if and(ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}
              : _OfficialBuildIdArgs: /p:OfficialBuildId=$(BUILD.BUILDNUMBER)

        steps:
        - task: Maven@3
          displayName: 'Maven build src'
          inputs:
            mavenPomFile: src/scala/pom.xml

        - task: Maven@3
          displayName: 'Maven build benchmark'
          inputs:
            mavenPomFile: benchmark/scala/pom.xml

        - script: build.cmd -pack
                  -c $(buildConfiguration)
                  -ci
                  /p:Version=$(DotnetPackageVersion)
                  /p:PublishSparkWorker=true
                  /p:SparkWorkerPublishDir=$(ArtifactPath)\Microsoft.Spark.Worker
                  /p:SparkWorkerPackageOutputDir=$(ArtifactPath)
                  /p:MicrosoftDiaSymReaderPdb2PdbVersion=1.1.0-beta1-62506-02
                  /property:Platform=x64
          displayName: "[BUILD] .NET Build"
        
        - script: |
            cd $(ArtifactPath)
            dir /B /S
          displayName: '[TEMP] Print ArtifactPath'

        - script: |
            cd $(Build.ArtifactStagingDirectory)
            dir /B /S
          displayName: '[TEMP] Print Build.ArtifactStagingDirectory'

        - task: EsrpCodeSigning@5
          displayName: 'ESRP CodeSigning MI based authentication'
          inputs:
            ConnectedServiceName: $(ConnectedServiceName)
            AppRegistrationClientId: $(AppRegistrationClientId)
            AppRegistrationTenantId: $(AppRegistrationTenantId)
            EsrpClientId: $(EsrpClientId)
            UseMSIAuthentication: true
            AuthAKVName: $(AuthAKVName)
            AuthSignCertName: $(AuthSignCertName)
            FolderPath: '$(ArtifactPath)/Microsoft.Spark.Worker'
            Pattern: |
              **/Microsoft.Spark*.dll
              **/Microsoft.Spark*.exe
            UseMinimatch: true
            OpusName: 'Microsoft'
            OpusInfo: 'http://www.microsoft.com'
            SessionTimeout: '60'
            MaxConcurrency: '50'
            MaxRetryAttempts: '5'
            PendingAnalysisWaitTimeoutMinutes: '5'
            signConfigType: inlineSignParams
            inlineOperation: >-
              [
                {
                  "KeyCode": "CP-230012",
                  "OperationCode": "SigntoolSign",
                  "ToolName": "sign",
                  "ToolVersion": "1.0",
                  "Parameters": {
                  "OpusName": "Microsoft",
                  "OpusInfo": "https://www.microsoft.com",
                  "FileDigest": "/fd SHA256",
                  "PageHash": "/NPH",
                  "TimeStamp": "/tr \"http://rfc3161.gtm.corp.microsoft.com/TSS/HttpTspServer\" /td sha256"
                  }
                },
                {
                  "KeyCode": "CP-230012",
                  "OperationCode": "SigntoolVerify",
                  "ToolName": "sign",
                  "ToolVersion": "1.0",
                  "Parameters": {}
                }
              ]
          
        - task: PowerShell@2
          displayName: "Pack Spark Worker Archives"
          inputs:
            targetType: "inline"
            script: |
              $OSTypes = "osx-x64", "linux-x64", "win-x64"
              foreach ($OSType in $OSTypes) {
                  $binaryFolder = "$(ArtifactPath)\Microsoft.Spark.Worker\net8.0"
                  New-Item -Path "$binaryFolder\$OSType-archive" -ItemType Directory -Force
                  Get-ChildItem -Path "$binaryFolder\$OSType" -Recurse | Move-Item -Destination "$binaryFolder\$OSType-archive\Microsoft.Spark.Worker-$(DotnetPackageVersion)"
                  $archiveFile_zip = "$binaryFolder\$OSType-archive\Microsoft.Spark.Worker.net8.0.$OSType-$(DotnetPackageVersion).zip"
                  Compress-Archive -Path $binaryFolder\$OSType-archive\Microsoft.Spark.Worker-$(DotnetPackageVersion) -DestinationPath $archiveFile_zip
                 
                  # Create tar.gz for linux-x64
                  if ($OSType -eq "linux-x64") {
                     $archiveFile_targz = "$binaryFolder\$OSType-archive\Microsoft.Spark.Worker.net8.0.$OSType-$(DotnetPackageVersion).tar.gz"
                     tar -czf $archiveFile_targz -C "$binaryFolder\$OSType-archive" Microsoft.Spark.Worker-$(DotnetPackageVersion)
                  }
              }
              $binaryFolder = "$(ArtifactPath)\Microsoft.Spark.Worker\net48"
              New-Item -Path "$binaryFolder\win-x64-archive" -ItemType Directory -Force
              Get-ChildItem -Path "$binaryFolder\$OSType" -Recurse | Move-Item -Destination "$binaryFolder\win-x64-archive\Microsoft.Spark.Worker-$(DotnetPackageVersion)"
              $archiveFile_zip = "$binaryFolder\win-x64-archive\Microsoft.Spark.Worker.net48.win-x64-$(DotnetPackageVersion).zip"
              Compress-Archive -Path $binaryFolder\win-x64-archive\Microsoft.Spark.Worker-$(DotnetPackageVersion) -DestinationPath $archiveFile_zip

        - task: CopyFiles@2
          displayName: '[COPY] Spark.Net .net8.0 worker archives -> $(ArtifactPath)/Output'
          inputs:
            SourceFolder: '$(ArtifactPath)\Microsoft.Spark.Worker\net8.0'
            Contents: |
              *\*.zip
              *\*.tar.gz
            TargetFolder: '$(ArtifactPath)\Output'
        
        - task: CopyFiles@2
          displayName: '[COPY] Spark.Net .net48 worker archive -> $(ArtifactPath)/Output'
          inputs:
            SourceFolder: '$(ArtifactPath)\Microsoft.Spark.Worker\net48'
            Contents: '*\*.zip'
            TargetFolder: '$(ArtifactPath)\Output'

        - task: CopyFiles@2
          displayName: '[COPY] Nupkg files -> $(ArtifactPath)/Output'
          inputs:
            SourceFolder: '$(Build.SourcesDirectory)\artifacts\packages\Release\NonShipping'
            Contents: '*.nupkg'
            TargetFolder: '$(ArtifactPath)\Output'
        
        - script: |
            cd $(ArtifactPath)/Output
            dir /B /S
          displayName: '[TEMP] Print $(ArtifactPath)/Output'

        - task: PowerShell@2
          displayName: "Extract Microsoft.Spark.dll from NuGet packages"
          inputs:
            targetType: "inline"
            script: |
              $workingDir = "$(ArtifactPath)\NuGetExtract"
              New-Item -Path $workingDir -ItemType Directory -Force
              
              Get-ChildItem -Path "$(ArtifactPath)\Output\Microsoft.Spark*.nupkg" | ForEach-Object {
                $nupkgPath = $_.FullName
                $extractPath = Join-Path $workingDir $_.BaseName
                
                # Convert nupkg to zip for extraction
                $zipPath = $nupkgPath -replace '\.nupkg$', '.zip'
                Copy-Item -Path $nupkgPath -Destination $zipPath -Force
                
                # Extract the zip file
                Expand-Archive -Path $zipPath -DestinationPath $extractPath -Force
                Remove-Item -Path $zipPath -Force
                
                # Copy all Microsoft.Spark*.dll files to a temp location for signing while preserving the lib folder structure
                Get-ChildItem -Path $extractPath\lib -Directory | ForEach-Object {
                  $frameworkDir = $_.Name
                  Get-ChildItem -Path $_.FullName -Filter "Microsoft.Spark*.dll" | ForEach-Object {
                    $packageName = (Split-Path $extractPath -Leaf)
                    $targetPath = Join-Path $workingDir "ToSign\$packageName\$frameworkDir"
                    New-Item -Path $targetPath -ItemType Directory -Force
                    Copy-Item $_.FullName -Destination $targetPath
                  }
                }
              }

        - task: EsrpCodeSigning@5
          displayName: 'Sign Microsoft.Spark*.dll files'
          inputs:
            ConnectedServiceName: $(ConnectedServiceName)
            AppRegistrationClientId: $(AppRegistrationClientId)
            AppRegistrationTenantId: $(AppRegistrationTenantId)
            EsrpClientId: $(EsrpClientId)
            UseMSIAuthentication: true
            AuthAKVName: $(AuthAKVName)
            AuthSignCertName: $(AuthSignCertName)
            FolderPath: '$(ArtifactPath)\NuGetExtract\ToSign'
            Pattern: '**\Microsoft.Spark*.dll'
            UseMinimatch: true
            OpusName: 'Microsoft'
            OpusInfo: 'http://www.microsoft.com'
            signConfigType: inlineSignParams
            inlineOperation: >-
              [
                {
                  "KeyCode": "CP-230012",
                  "OperationCode": "SigntoolSign",
                  "ToolName": "sign",
                  "ToolVersion": "1.0",
                  "Parameters": {
                    "OpusName": "Microsoft",
                    "OpusInfo": "https://www.microsoft.com",
                    "FileDigest": "/fd SHA256",
                    "PageHash": "/NPH",
                    "TimeStamp": "/tr \"http://rfc3161.gtm.corp.microsoft.com/TSS/HttpTspServer\" /td sha256"
                  }
                },
                {
                  "KeyCode": "CP-230012",
                  "OperationCode": "SigntoolVerify",
                  "ToolName": "sign",
                  "ToolVersion": "1.0",
                  "Parameters": {}
                }
              ]

        - task: PowerShell@2
          displayName: "Repackage signed Microsoft.Spark.*.dll into NuGet packages"
          inputs:
            targetType: "inline"
            script: |
              # Load required assemblies for ZIP operations
              Add-Type -AssemblyName System.IO.Compression
              Add-Type -AssemblyName System.IO.Compression.FileSystem

              $workingDir = "$(ArtifactPath)\NuGetExtract"

              $packages = Get-ChildItem -Path "$workingDir" -Directory | Where-Object { $_.Name -ne "ToSign" }
              foreach ($package in $packages) {
                $packageDir = $package.FullName
                $packageName = $package.Name

                # Replace Microsoft.Spark*.dll files with their signed versions for each framework
                $frameworks = Get-ChildItem -Path (Join-Path $packageDir "lib") -Directory
                foreach ($framework in $frameworks) {
                  $dllFiles = Get-ChildItem -Path $framework.FullName -Filter "Microsoft.Spark*.dll"
                  foreach ($dll in $dllFiles) {
                    $signedDllPath = Join-Path $workingDir "ToSign\$packageName\$($framework.Name)\$($dll.Name)"
                    if (Test-Path $signedDllPath) {
                      Copy-Item -Path $signedDllPath -Destination $dll.FullName -Force
                    }
                  }
                }

                $nupkgPath = Join-Path "$(ArtifactPath)\Output" "$packageName.nupkg"
                Remove-Item -Path $nupkgPath -Force -ErrorAction SilentlyContinue

                # Create nupkg with forward-slash paths for cross-platform compatibility
                # Using .NET ZipFile API to ensure forward slashes in archive entry names
                $zip = [System.IO.Compression.ZipFile]::Open($nupkgPath, [System.IO.Compression.ZipArchiveMode]::Create)
                try {
                  Get-ChildItem -Path $packageDir -Recurse -File | ForEach-Object {
                    $relativePath = $_.FullName.Substring($packageDir.Length + 1)
                    # Normalize path separators to forward slashes for cross-platform compatibility
                    $entryName = $relativePath.Replace('\', '/')
                    [System.IO.Compression.ZipFileExtensions]::CreateEntryFromFile($zip, $_.FullName, $entryName) | Out-Null
                  }
                } finally {
                  $zip.Dispose()
                }
              }

        - task: EsrpCodeSigning@5
          inputs:
            ConnectedServiceName: $(ConnectedServiceName)
            AppRegistrationClientId: $(AppRegistrationClientId)
            AppRegistrationTenantId: $(AppRegistrationTenantId)
            EsrpClientId: $(EsrpClientId)
            UseMSIAuthentication: true
            AuthAKVName: $(AuthAKVName)
            AuthSignCertName: $(AuthSignCertName)
            FolderPath: '$(ArtifactPath)/Output'
            Pattern: |
              Microsoft.Spark*.nupkg
            UseMinimatch: true
            signConfigType: inlineSignParams
            inlineOperation: >-
              [
                {
                  "keyCode": "CP-401405",
                  "operationSetCode": "NuGetSign",
                  "parameters": [],
                  "toolName": "sign",
                  "toolVersion": "1.0"
                },
                {
                  "keyCode": "CP-401405",
                  "operationSetCode": "NuGetVerify",
                  "parameters": [],
                  "toolName": "sign",
                  "toolVersion": "1.0"
                }
              ]

        - task: NuGetCommand@2
          displayName: 'Verify NuGet Packages'
          inputs:
            command: 'custom'
            arguments: 'search -Source $(ArtifactPath)/Output'
          continueOnError: true

        - script: |
            cd $(ArtifactPath)
            dir /B /S
          displayName: '[TEMP] Print ArtifactPath'

        - script: |
            cd $(Build.SourcesDirectory)
            dir /B /S
          displayName: '[TEMP] Print SourcesDirectory'

    - stage: ValidateLinux
      displayName: Validate Packages on Linux
      dependsOn: Build
      pool:
        name: Cosmos2MT-AzureDevOps-AgentPool
        image: 1es-pt-mariner-2.0-gen2
        os: linux
      jobs:
      - job: ValidateNuGetPackages
        displayName: Validate NuGet Package Installation
        steps:
        - task: DownloadPipelineArtifact@2
          displayName: Download DotnetSpark Artifacts
          inputs:
            artifact: DotnetSpark
            path: $(Pipeline.Workspace)/DotnetSpark

        - task: UseDotNet@2
          displayName: Install .NET SDK
          inputs:
            packageType: 'sdk'
            version: '8.x'

        - bash: |
            set -e
            echo "=== Validating NuGet packages on Linux ==="

            ARTIFACT_DIR="$(Pipeline.Workspace)/DotnetSpark"
            TEST_DIR="$(Pipeline.Workspace)/validate-test"

            # Get the package version from the nupkg filename
            NUPKG_FILE=$(ls $ARTIFACT_DIR/Microsoft.Spark.*.nupkg | grep -v Worker | head -1)
            PACKAGE_VERSION=$(basename "$NUPKG_FILE" | sed 's/Microsoft.Spark\.\(.*\)\.nupkg/\1/')
            echo "Package version: $PACKAGE_VERSION"

            # Create a test project
            mkdir -p "$TEST_DIR"
            cd "$TEST_DIR"

            echo "Creating test console project..."
            dotnet new console -n SparkValidation --framework net8.0
            cd SparkValidation

            # Add local NuGet source pointing to artifact directory
            dotnet nuget add source "$ARTIFACT_DIR" --name LocalPackages

            # Add the Microsoft.Spark package reference
            echo "Adding Microsoft.Spark package reference..."
            dotnet add package Microsoft.Spark --version "$PACKAGE_VERSION" --source LocalPackages

            # Create a simple test program that references Microsoft.Spark
            cat << 'CSHARP' | sed 's/^            //' > Program.cs
            using System;
            using System.Reflection;

            // Try to load Microsoft.Spark assembly
            var sparkAssembly = Assembly.Load("Microsoft.Spark");
            Console.WriteLine($"Successfully loaded: {sparkAssembly.FullName}");
            Console.WriteLine($"Location: {sparkAssembly.Location}");

            // Verify key types exist
            var sparkSessionType = sparkAssembly.GetType("Microsoft.Spark.Sql.SparkSession");
            if (sparkSessionType != null)
            {
                Console.WriteLine($"Found type: {sparkSessionType.FullName}");
            }
            else
            {
                Console.WriteLine("ERROR: Could not find SparkSession type");
                Environment.Exit(1);
            }

            Console.WriteLine("VALIDATION PASSED: Package installed and loaded successfully on Linux");
            CSHARP

            # Build and run the test
            echo "Building test project..."
            dotnet build

            echo "Running validation test..."
            dotnet run

            echo ""
            echo "=== Linux validation completed successfully ==="
          displayName: Validate NuGet Package Installation

        - bash: |
            set -e
            echo "=== Validating code signatures on Linux ==="

            ARTIFACT_DIR="$(Pipeline.Workspace)/DotnetSpark"
            EXTRACT_DIR="$(Pipeline.Workspace)/signature-check"
            mkdir -p "$EXTRACT_DIR"

            # Install osslsigncode for Authenticode signature verification
            echo "Installing osslsigncode..."
            sudo tdnf install -y osslsigncode 2>/dev/null || sudo yum install -y osslsigncode 2>/dev/null || sudo apt-get install -y osslsigncode 2>/dev/null || {
              echo "WARNING: Could not install osslsigncode, will skip Authenticode verification"
            }

            # Verify NuGet package signatures
            echo ""
            echo "--- Verifying NuGet package signatures ---"
            for nupkg in $ARTIFACT_DIR/Microsoft.Spark*.nupkg; do
              if [ -f "$nupkg" ]; then
                PACKAGE_NAME=$(basename "$nupkg")
                echo ""
                echo "Verifying signature of $PACKAGE_NAME..."
                dotnet nuget verify "$nupkg" --all --verbosity detailed || {
                  echo "WARNING: Package $PACKAGE_NAME signature verification failed or package is not signed"
                }
              fi
            done

            # Function to verify Authenticode signature and display details
            verify_authenticode() {
              local file="$1"
              local relative_path="$2"

              echo ""
              echo "  File: $relative_path"

              if command -v osslsigncode &> /dev/null; then
                # Extract signature info using osslsigncode
                local sig_output=$(osslsigncode verify -in "$file" 2>&1)
                local sig_status=$?

                if [ $sig_status -eq 0 ]; then
                  echo "  Status: Valid"
                else
                  echo "  Status: NotSigned or Invalid"
                fi

                # Extract certificate details
                local subject=$(echo "$sig_output" | grep -i "Subject:" | head -1 | sed 's/.*Subject: //')
                local issuer=$(echo "$sig_output" | grep -i "Issuer:" | head -1 | sed 's/.*Issuer: //')
                local serial=$(echo "$sig_output" | grep -i "Serial:" | head -1 | sed 's/.*Serial: //')
                local not_before=$(echo "$sig_output" | grep -i "notBefore:" | head -1 | sed 's/.*notBefore: //')
                local not_after=$(echo "$sig_output" | grep -i "notAfter:" | head -1 | sed 's/.*notAfter: //')

                [ -n "$subject" ] && echo "  Subject: $subject"
                [ -n "$issuer" ] && echo "  Issuer: $issuer"
                [ -n "$serial" ] && echo "  Serial: $serial"
                [ -n "$not_before" ] && echo "  Valid From: $not_before"
                [ -n "$not_after" ] && echo "  Valid To: $not_after"

                # Check for timestamp
                if echo "$sig_output" | grep -qi "timestamp"; then
                  local ts_info=$(echo "$sig_output" | grep -i "Timestamp" | head -1)
                  [ -n "$ts_info" ] && echo "  Timestamper: $ts_info"
                fi
              else
                echo "  Status: (osslsigncode not available for verification)"
              fi
            }

            # Verify Authenticode signatures on DLLs inside NuGet packages
            echo ""
            echo "--- Verifying Authenticode signatures on DLLs ---"
            for nupkg in $ARTIFACT_DIR/Microsoft.Spark*.nupkg; do
              if [ -f "$nupkg" ] && [[ ! "$nupkg" == *"Worker"* ]]; then
                PACKAGE_NAME=$(basename "$nupkg" .nupkg)
                PACKAGE_DIR="$EXTRACT_DIR/$PACKAGE_NAME"
                mkdir -p "$PACKAGE_DIR"
                unzip -q "$nupkg" -d "$PACKAGE_DIR"

                echo ""
                echo "Checking signatures in $PACKAGE_NAME:"
                find "$PACKAGE_DIR" -name "Microsoft.Spark*.dll" -type f | while read dll; do
                  RELATIVE_PATH="${dll#$PACKAGE_DIR/}"
                  verify_authenticode "$dll" "$RELATIVE_PATH"
                done
              fi
            done

            # Verify signatures on Worker archives (Linux tar.gz)
            echo ""
            echo "--- Verifying Authenticode signatures on Worker executables ---"
            for targz in $ARTIFACT_DIR/*Worker*linux*.tar.gz; do
              if [ -f "$targz" ]; then
                ARCHIVE_NAME=$(basename "$targz" .tar.gz)
                WORKER_DIR="$EXTRACT_DIR/$ARCHIVE_NAME"
                mkdir -p "$WORKER_DIR"
                tar -xzf "$targz" -C "$WORKER_DIR"

                echo ""
                echo "Checking signatures in $ARCHIVE_NAME:"
                find "$WORKER_DIR" -type f \( -name "Microsoft.Spark*.dll" -o -name "Microsoft.Spark*.exe" \) | while read file; do
                  RELATIVE_PATH="${file#$WORKER_DIR/}"
                  verify_authenticode "$file" "$RELATIVE_PATH"
                done
              fi
            done

            echo ""
            echo "=== Linux signature validation completed ==="
          displayName: Validate Code Signatures

    - stage: ValidateWindows
      displayName: Validate Packages on Windows
      dependsOn: Build
      pool:
        name: Cosmos2MT-AzureDevOps-AgentPool
        image: 1es-pt-windows-2022
        os: windows
      jobs:
      - job: ValidateNuGetPackages
        displayName: Validate NuGet Package Installation
        steps:
        - task: DownloadPipelineArtifact@2
          displayName: Download DotnetSpark Artifacts
          inputs:
            artifact: DotnetSpark
            path: $(Pipeline.Workspace)/DotnetSpark

        - task: UseDotNet@2
          displayName: Install .NET SDK
          inputs:
            packageType: 'sdk'
            version: '8.x'

        - task: PowerShell@2
          displayName: Validate NuGet Package Installation
          inputs:
            targetType: "inline"
            script: |
              $ErrorActionPreference = "Stop"
              Write-Host "=== Validating NuGet packages on Windows ==="

              $artifactDir = "$(Pipeline.Workspace)/DotnetSpark"
              $testDir = "$(Pipeline.Workspace)/validate-test"

              # Get the package version from the nupkg filename
              $nupkgFile = Get-ChildItem "$artifactDir/Microsoft.Spark.*.nupkg" | Where-Object { $_.Name -notlike "*Worker*" } | Select-Object -First 1
              $packageVersion = $nupkgFile.BaseName -replace "Microsoft\.Spark\.", ""
              Write-Host "Package version: $packageVersion"

              # Create a test project
              New-Item -Path $testDir -ItemType Directory -Force | Out-Null
              Set-Location $testDir

              Write-Host "Creating test console project..."
              dotnet new console -n SparkValidation --framework net8.0
              Set-Location SparkValidation

              # Add local NuGet source pointing to artifact directory
              dotnet nuget add source $artifactDir --name LocalPackages

              # Add the Microsoft.Spark package reference
              Write-Host "Adding Microsoft.Spark package reference..."
              dotnet add package Microsoft.Spark --version $packageVersion --source LocalPackages

              # Create a simple test program that references Microsoft.Spark
              $programCs = @'
              using System;
              using System.Reflection;

              // Try to load Microsoft.Spark assembly
              var sparkAssembly = Assembly.Load("Microsoft.Spark");
              Console.WriteLine($"Successfully loaded: {sparkAssembly.FullName}");
              Console.WriteLine($"Location: {sparkAssembly.Location}");

              // Verify key types exist
              var sparkSessionType = sparkAssembly.GetType("Microsoft.Spark.Sql.SparkSession");
              if (sparkSessionType != null)
              {
                  Console.WriteLine($"Found type: {sparkSessionType.FullName}");
              }
              else
              {
                  Console.WriteLine("ERROR: Could not find SparkSession type");
                  Environment.Exit(1);
              }

              Console.WriteLine("VALIDATION PASSED: Package installed and loaded successfully on Windows");
              '@
              # Strip leading 14 spaces from each line (the YAML indentation)
              $programCs = $programCs -replace '(?m)^              ', ''
              Set-Content -Path "Program.cs" -Value $programCs

              # Build and run the test
              Write-Host "Building test project..."
              dotnet build

              Write-Host "Running validation test..."
              dotnet run

              Write-Host ""
              Write-Host "=== Windows validation completed successfully ==="

        - task: PowerShell@2
          displayName: Validate Code Signatures
          inputs:
            targetType: "inline"
            script: |
              $ErrorActionPreference = "Stop"
              Write-Host "=== Validating code signatures on Windows ==="

              $artifactDir = "$(Pipeline.Workspace)/DotnetSpark"
              $validationFailed = $false

              # Verify NuGet package signatures
              Write-Host ""
              Write-Host "--- Verifying NuGet package signatures ---"
              Get-ChildItem "$artifactDir/Microsoft.Spark*.nupkg" | ForEach-Object {
                $nupkg = $_.FullName
                $packageName = $_.Name
                Write-Host ""
                Write-Host "Verifying signature of $packageName..."
                $result = dotnet nuget verify $nupkg --all --verbosity detailed 2>&1
                Write-Host $result
                if ($LASTEXITCODE -eq 0) {
                  Write-Host "OK: $packageName is properly signed"
                } else {
                  Write-Host "WARNING: $packageName signature verification failed or package is not signed"
                }
              }

              # Verify Authenticode signatures on DLLs inside NuGet packages
              Write-Host ""
              Write-Host "--- Verifying Authenticode signatures on DLLs ---"
              $extractDir = Join-Path $artifactDir "signature-check"
              New-Item -Path $extractDir -ItemType Directory -Force | Out-Null

              Get-ChildItem "$artifactDir/Microsoft.Spark*.nupkg" | Where-Object { $_.Name -notlike "*Worker*" } | ForEach-Object {
                $nupkg = $_.FullName
                $packageName = $_.BaseName
                $packageExtractDir = Join-Path $extractDir $packageName

                # Extract package
                Add-Type -AssemblyName System.IO.Compression.FileSystem
                [System.IO.Compression.ZipFile]::ExtractToDirectory($nupkg, $packageExtractDir)

                Write-Host ""
                Write-Host "Checking signatures in $packageName`:"

                # Check DLL signatures with detailed info
                Get-ChildItem -Path $packageExtractDir -Recurse -Filter "Microsoft.Spark*.dll" | ForEach-Object {
                  $dll = $_.FullName
                  $relativePath = $_.FullName.Substring($packageExtractDir.Length + 1)
                  $sig = Get-AuthenticodeSignature $dll

                  Write-Host ""
                  Write-Host "  File: $relativePath"
                  Write-Host "  Status: $($sig.Status)"
                  if ($sig.SignerCertificate) {
                    Write-Host "  Subject: $($sig.SignerCertificate.Subject)"
                    Write-Host "  Issuer: $($sig.SignerCertificate.Issuer)"
                    Write-Host "  Thumbprint: $($sig.SignerCertificate.Thumbprint)"
                    Write-Host "  Valid From: $($sig.SignerCertificate.NotBefore)"
                    Write-Host "  Valid To: $($sig.SignerCertificate.NotAfter)"
                  }
                  if ($sig.TimeStamperCertificate) {
                    Write-Host "  Timestamper: $($sig.TimeStamperCertificate.Subject)"
                  }
                }
              }

              # Verify Authenticode signatures on Worker executables
              Write-Host ""
              Write-Host "--- Verifying Authenticode signatures on Worker archives ---"
              Get-ChildItem "$artifactDir/*.zip" | Where-Object { $_.Name -like "*Worker*" -and $_.Name -like "*win*" } | ForEach-Object {
                $zipPath = $_.FullName
                $zipName = $_.BaseName
                $workerExtractDir = Join-Path $extractDir $zipName

                # Extract worker archive
                Expand-Archive -Path $zipPath -DestinationPath $workerExtractDir -Force

                Write-Host ""
                Write-Host "Checking signatures in $zipName`:"

                # Check exe and dll signatures with detailed info
                Get-ChildItem -Path $workerExtractDir -Recurse -Include "*.exe","*.dll" | Where-Object { $_.Name -like "Microsoft.Spark*" } | ForEach-Object {
                  $file = $_.FullName
                  $relativePath = $_.FullName.Substring($workerExtractDir.Length + 1)
                  $sig = Get-AuthenticodeSignature $file

                  Write-Host ""
                  Write-Host "  File: $relativePath"
                  Write-Host "  Status: $($sig.Status)"
                  if ($sig.SignerCertificate) {
                    Write-Host "  Subject: $($sig.SignerCertificate.Subject)"
                    Write-Host "  Issuer: $($sig.SignerCertificate.Issuer)"
                    Write-Host "  Thumbprint: $($sig.SignerCertificate.Thumbprint)"
                    Write-Host "  Valid From: $($sig.SignerCertificate.NotBefore)"
                    Write-Host "  Valid To: $($sig.SignerCertificate.NotAfter)"
                  }
                  if ($sig.TimeStamperCertificate) {
                    Write-Host "  Timestamper: $($sig.TimeStamperCertificate.Subject)"
                  }
                }
              }

              Write-Host ""
              Write-Host "=== Windows signature validation completed ==="
